# Task 1 - 4-bit LFSR and Pseudo Random Binary Sequence
## Step 1 - create the component lfsr.sv
Create component in Lecture 4 slide 14.

## Step 2 - Create the testbench for the LFSR
```cpp
#include "verilated.h"
#include "verilated_vcd_c.h"
#include "Vlfsr.h"

#include "vbuddy.cpp"     // include vbuddy code
#define MAX_SIM_CYC 10000
#define ADDRESS_WIDTH 8

int main(int argc, char **argv, char **env) {
  int simcyc;     // simulation clock count
  int tick;       // each clk cycle has two ticks for two edges

  Verilated::commandArgs(argc, argv);
  // init top verilog instance
  Vlfsr* top = new Vlfsr;
  // init trace dump
  Verilated::traceEverOn(true);
  VerilatedVcdC* tfp = new VerilatedVcdC;
  top->trace (tfp, 99);
  tfp->open ("lfsr.vcd");
 
  // init Vbuddy
  if (vbdOpen()!=1) return(-1);
  vbdHeader("LFSR");
  vbdSetMode(1);        // Flag mode set to one-shot

  // initialize simulation inputs
  top->clk = 1;
  top->rst = 1;
  top->en = 1;

  // run simulation for MAX_SIM_CYC clock cycles
  for (simcyc=0; simcyc<MAX_SIM_CYC; simcyc++) {
    // dump variables into VCD file and toggle clock
    for (tick=0; tick<2; tick++) {
      tfp->dump (2*simcyc+tick);
      top->clk = !top->clk;
      top->eval();
    }
    
    top->rst = 0;
    top->en = vbdFlag();
    //vbdSetMode(1);
    
    vbdHex(1, top->data_out & 0xF); // 1 7 segment display
    vbdBar(top->data_out & 0xFF); // display on the neopixel strip
     
    vbdCycle(simcyc+1);

    // either simulation finished, or 'q' is pressed
    if ((Verilated::gotFinish()) || (vbdGetkey()=='q')) 
      exit(0);                // ... exit if finish OR 'q' pressed
  }

  vbdClose();     // ++++
  tfp->close(); 
  exit(0);
}
```

## Step 3 - Create the doit.sh script
Pretty standard name changes etc.
```shell
#!/bin/sh

#cleanup
rm -rf obj_dir
rm -f lfsr.vcd

# run Verilator to translate Verilog into C++, including C++ testbench
verilator -Wall --cc --trace lfsr.sv --exe lfsr_tb.cpp

# build C++ project via make automatically generated by Verilator
make -j -C obj_dir/ -f Vlfsr.mk Vlfsr

# run executable simulation file
obj_dir/Vlfsr
```

## Test yourself challenge
Modify lfsr.sv into a 7 bit PRBS generator, with the primitive polynomial $1 + X^3 + X^7$.
### Change 1: sv module
Increase bit width and change XOR values to implement polynomial.
```systemverilog
module lfsr (
    input logic clk,
    input logic rst,
    input logic en,
    output logic [7:1] data_out //new width
);

    logic[7:1] sreg;  //new width

always_ff @ (posedge clk, posedge rst)
    if (rst)
        sreg <= 7'b1; //new width
    else if (en)
        sreg <= {sreg[6:1], sreg[7] ^ sreg[3]}; //New logic, XOR 7th and 3rd bit to implement polynomial

assign data_out = sreg;
endmodule
```

### Change 2: testbench
Use vbdHex to display 2 digits instead of one.
```cpp
// 2 7 segment displays
vbdHex(2, (top->data_out >> 4) & 0xF);
vbdHex(1, top->data_out & 0xF);
vbdBar(top->data_out & 0xFF); // display on the neopixel strip
```